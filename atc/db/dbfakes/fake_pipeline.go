// Code generated by counterfeiter. DO NOT EDIT.
package dbfakes

import (
	sync "sync"
	time "time"

	lager "code.cloudfoundry.org/lager"
	atc "github.com/concourse/concourse/atc"
	db "github.com/concourse/concourse/atc/db"
	algorithm "github.com/concourse/concourse/atc/db/algorithm"
	lock "github.com/concourse/concourse/atc/db/lock"
)

type FakePipeline struct {
	AcquireSchedulingLockStub        func(lager.Logger, time.Duration) (lock.Lock, bool, error)
	acquireSchedulingLockMutex       sync.RWMutex
	acquireSchedulingLockArgsForCall []struct {
		arg1 lager.Logger
		arg2 time.Duration
	}
	acquireSchedulingLockReturns struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	acquireSchedulingLockReturnsOnCall map[int]struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}
	BuildsStub        func(db.Page) ([]db.Build, db.Pagination, error)
	buildsMutex       sync.RWMutex
	buildsArgsForCall []struct {
		arg1 db.Page
	}
	buildsReturns struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}
	buildsReturnsOnCall map[int]struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}
	BuildsWithTimeStub        func(db.Page) ([]db.Build, db.Pagination, error)
	buildsWithTimeMutex       sync.RWMutex
	buildsWithTimeArgsForCall []struct {
		arg1 db.Page
	}
	buildsWithTimeReturns struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}
	buildsWithTimeReturnsOnCall map[int]struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}
	CausalityStub        func(int) ([]db.Cause, error)
	causalityMutex       sync.RWMutex
	causalityArgsForCall []struct {
		arg1 int
	}
	causalityReturns struct {
		result1 []db.Cause
		result2 error
	}
	causalityReturnsOnCall map[int]struct {
		result1 []db.Cause
		result2 error
	}
	CheckPausedStub        func() (bool, error)
	checkPausedMutex       sync.RWMutex
	checkPausedArgsForCall []struct {
	}
	checkPausedReturns struct {
		result1 bool
		result2 error
	}
	checkPausedReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	ConfigVersionStub        func() db.ConfigVersion
	configVersionMutex       sync.RWMutex
	configVersionArgsForCall []struct {
	}
	configVersionReturns struct {
		result1 db.ConfigVersion
	}
	configVersionReturnsOnCall map[int]struct {
		result1 db.ConfigVersion
	}
	CreateOneOffBuildStub        func() (db.Build, error)
	createOneOffBuildMutex       sync.RWMutex
	createOneOffBuildArgsForCall []struct {
	}
	createOneOffBuildReturns struct {
		result1 db.Build
		result2 error
	}
	createOneOffBuildReturnsOnCall map[int]struct {
		result1 db.Build
		result2 error
	}
	CreateStartedBuildStub        func(atc.Plan) (db.Build, error)
	createStartedBuildMutex       sync.RWMutex
	createStartedBuildArgsForCall []struct {
		arg1 atc.Plan
	}
	createStartedBuildReturns struct {
		result1 db.Build
		result2 error
	}
	createStartedBuildReturnsOnCall map[int]struct {
		result1 db.Build
		result2 error
	}
	DashboardStub        func() (db.Dashboard, error)
	dashboardMutex       sync.RWMutex
	dashboardArgsForCall []struct {
	}
	dashboardReturns struct {
		result1 db.Dashboard
		result2 error
	}
	dashboardReturnsOnCall map[int]struct {
		result1 db.Dashboard
		result2 error
	}
	DeleteBuildEventsByBuildIDsStub        func([]int) error
	deleteBuildEventsByBuildIDsMutex       sync.RWMutex
	deleteBuildEventsByBuildIDsArgsForCall []struct {
		arg1 []int
	}
	deleteBuildEventsByBuildIDsReturns struct {
		result1 error
	}
	deleteBuildEventsByBuildIDsReturnsOnCall map[int]struct {
		result1 error
	}
	DestroyStub        func() error
	destroyMutex       sync.RWMutex
	destroyArgsForCall []struct {
	}
	destroyReturns struct {
		result1 error
	}
	destroyReturnsOnCall map[int]struct {
		result1 error
	}
	ExposeStub        func() error
	exposeMutex       sync.RWMutex
	exposeArgsForCall []struct {
	}
	exposeReturns struct {
		result1 error
	}
	exposeReturnsOnCall map[int]struct {
		result1 error
	}
	GetAllPendingBuildsStub        func() (map[string][]db.Build, error)
	getAllPendingBuildsMutex       sync.RWMutex
	getAllPendingBuildsArgsForCall []struct {
	}
	getAllPendingBuildsReturns struct {
		result1 map[string][]db.Build
		result2 error
	}
	getAllPendingBuildsReturnsOnCall map[int]struct {
		result1 map[string][]db.Build
		result2 error
	}
	GetBuildsWithVersionAsInputStub        func(int, int) ([]db.Build, error)
	getBuildsWithVersionAsInputMutex       sync.RWMutex
	getBuildsWithVersionAsInputArgsForCall []struct {
		arg1 int
		arg2 int
	}
	getBuildsWithVersionAsInputReturns struct {
		result1 []db.Build
		result2 error
	}
	getBuildsWithVersionAsInputReturnsOnCall map[int]struct {
		result1 []db.Build
		result2 error
	}
	GetBuildsWithVersionAsOutputStub        func(int, int) ([]db.Build, error)
	getBuildsWithVersionAsOutputMutex       sync.RWMutex
	getBuildsWithVersionAsOutputArgsForCall []struct {
		arg1 int
		arg2 int
	}
	getBuildsWithVersionAsOutputReturns struct {
		result1 []db.Build
		result2 error
	}
	getBuildsWithVersionAsOutputReturnsOnCall map[int]struct {
		result1 []db.Build
		result2 error
	}
	GroupsStub        func() atc.GroupConfigs
	groupsMutex       sync.RWMutex
	groupsArgsForCall []struct {
	}
	groupsReturns struct {
		result1 atc.GroupConfigs
	}
	groupsReturnsOnCall map[int]struct {
		result1 atc.GroupConfigs
	}
	HideStub        func() error
	hideMutex       sync.RWMutex
	hideArgsForCall []struct {
	}
	hideReturns struct {
		result1 error
	}
	hideReturnsOnCall map[int]struct {
		result1 error
	}
	IDStub        func() int
	iDMutex       sync.RWMutex
	iDArgsForCall []struct {
	}
	iDReturns struct {
		result1 int
	}
	iDReturnsOnCall map[int]struct {
		result1 int
	}
	JobStub        func(string) (db.Job, bool, error)
	jobMutex       sync.RWMutex
	jobArgsForCall []struct {
		arg1 string
	}
	jobReturns struct {
		result1 db.Job
		result2 bool
		result3 error
	}
	jobReturnsOnCall map[int]struct {
		result1 db.Job
		result2 bool
		result3 error
	}
	JobsStub        func() (db.Jobs, error)
	jobsMutex       sync.RWMutex
	jobsArgsForCall []struct {
	}
	jobsReturns struct {
		result1 db.Jobs
		result2 error
	}
	jobsReturnsOnCall map[int]struct {
		result1 db.Jobs
		result2 error
	}
	LoadVersionsDBStub        func() (*algorithm.VersionsDB, error)
	loadVersionsDBMutex       sync.RWMutex
	loadVersionsDBArgsForCall []struct {
	}
	loadVersionsDBReturns struct {
		result1 *algorithm.VersionsDB
		result2 error
	}
	loadVersionsDBReturnsOnCall map[int]struct {
		result1 *algorithm.VersionsDB
		result2 error
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct {
	}
	nameReturns struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	PauseStub        func() error
	pauseMutex       sync.RWMutex
	pauseArgsForCall []struct {
	}
	pauseReturns struct {
		result1 error
	}
	pauseReturnsOnCall map[int]struct {
		result1 error
	}
	PausedStub        func() bool
	pausedMutex       sync.RWMutex
	pausedArgsForCall []struct {
	}
	pausedReturns struct {
		result1 bool
	}
	pausedReturnsOnCall map[int]struct {
		result1 bool
	}
	PublicStub        func() bool
	publicMutex       sync.RWMutex
	publicArgsForCall []struct {
	}
	publicReturns struct {
		result1 bool
	}
	publicReturnsOnCall map[int]struct {
		result1 bool
	}
	ReloadStub        func() (bool, error)
	reloadMutex       sync.RWMutex
	reloadArgsForCall []struct {
	}
	reloadReturns struct {
		result1 bool
		result2 error
	}
	reloadReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	RenameStub        func(string) error
	renameMutex       sync.RWMutex
	renameArgsForCall []struct {
		arg1 string
	}
	renameReturns struct {
		result1 error
	}
	renameReturnsOnCall map[int]struct {
		result1 error
	}
	ResourceStub        func(string) (db.Resource, bool, error)
	resourceMutex       sync.RWMutex
	resourceArgsForCall []struct {
		arg1 string
	}
	resourceReturns struct {
		result1 db.Resource
		result2 bool
		result3 error
	}
	resourceReturnsOnCall map[int]struct {
		result1 db.Resource
		result2 bool
		result3 error
	}
	ResourceTypeStub        func(string) (db.ResourceType, bool, error)
	resourceTypeMutex       sync.RWMutex
	resourceTypeArgsForCall []struct {
		arg1 string
	}
	resourceTypeReturns struct {
		result1 db.ResourceType
		result2 bool
		result3 error
	}
	resourceTypeReturnsOnCall map[int]struct {
		result1 db.ResourceType
		result2 bool
		result3 error
	}
	ResourceTypesStub        func() (db.ResourceTypes, error)
	resourceTypesMutex       sync.RWMutex
	resourceTypesArgsForCall []struct {
	}
	resourceTypesReturns struct {
		result1 db.ResourceTypes
		result2 error
	}
	resourceTypesReturnsOnCall map[int]struct {
		result1 db.ResourceTypes
		result2 error
	}
	ResourceVersionStub        func(int) (atc.ResourceVersion, bool, error)
	resourceVersionMutex       sync.RWMutex
	resourceVersionArgsForCall []struct {
		arg1 int
	}
	resourceVersionReturns struct {
		result1 atc.ResourceVersion
		result2 bool
		result3 error
	}
	resourceVersionReturnsOnCall map[int]struct {
		result1 atc.ResourceVersion
		result2 bool
		result3 error
	}
	ResourcesStub        func() (db.Resources, error)
	resourcesMutex       sync.RWMutex
	resourcesArgsForCall []struct {
	}
	resourcesReturns struct {
		result1 db.Resources
		result2 error
	}
	resourcesReturnsOnCall map[int]struct {
		result1 db.Resources
		result2 error
	}
	TeamIDStub        func() int
	teamIDMutex       sync.RWMutex
	teamIDArgsForCall []struct {
	}
	teamIDReturns struct {
		result1 int
	}
	teamIDReturnsOnCall map[int]struct {
		result1 int
	}
	TeamNameStub        func() string
	teamNameMutex       sync.RWMutex
	teamNameArgsForCall []struct {
	}
	teamNameReturns struct {
		result1 string
	}
	teamNameReturnsOnCall map[int]struct {
		result1 string
	}
	UnpauseStub        func() error
	unpauseMutex       sync.RWMutex
	unpauseArgsForCall []struct {
	}
	unpauseReturns struct {
		result1 error
	}
	unpauseReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePipeline) AcquireSchedulingLock(arg1 lager.Logger, arg2 time.Duration) (lock.Lock, bool, error) {
	fake.acquireSchedulingLockMutex.Lock()
	ret, specificReturn := fake.acquireSchedulingLockReturnsOnCall[len(fake.acquireSchedulingLockArgsForCall)]
	fake.acquireSchedulingLockArgsForCall = append(fake.acquireSchedulingLockArgsForCall, struct {
		arg1 lager.Logger
		arg2 time.Duration
	}{arg1, arg2})
	fake.recordInvocation("AcquireSchedulingLock", []interface{}{arg1, arg2})
	fake.acquireSchedulingLockMutex.Unlock()
	if fake.AcquireSchedulingLockStub != nil {
		return fake.AcquireSchedulingLockStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.acquireSchedulingLockReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePipeline) AcquireSchedulingLockCallCount() int {
	fake.acquireSchedulingLockMutex.RLock()
	defer fake.acquireSchedulingLockMutex.RUnlock()
	return len(fake.acquireSchedulingLockArgsForCall)
}

func (fake *FakePipeline) AcquireSchedulingLockCalls(stub func(lager.Logger, time.Duration) (lock.Lock, bool, error)) {
	fake.acquireSchedulingLockMutex.Lock()
	defer fake.acquireSchedulingLockMutex.Unlock()
	fake.AcquireSchedulingLockStub = stub
}

func (fake *FakePipeline) AcquireSchedulingLockArgsForCall(i int) (lager.Logger, time.Duration) {
	fake.acquireSchedulingLockMutex.RLock()
	defer fake.acquireSchedulingLockMutex.RUnlock()
	argsForCall := fake.acquireSchedulingLockArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePipeline) AcquireSchedulingLockReturns(result1 lock.Lock, result2 bool, result3 error) {
	fake.acquireSchedulingLockMutex.Lock()
	defer fake.acquireSchedulingLockMutex.Unlock()
	fake.AcquireSchedulingLockStub = nil
	fake.acquireSchedulingLockReturns = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) AcquireSchedulingLockReturnsOnCall(i int, result1 lock.Lock, result2 bool, result3 error) {
	fake.acquireSchedulingLockMutex.Lock()
	defer fake.acquireSchedulingLockMutex.Unlock()
	fake.AcquireSchedulingLockStub = nil
	if fake.acquireSchedulingLockReturnsOnCall == nil {
		fake.acquireSchedulingLockReturnsOnCall = make(map[int]struct {
			result1 lock.Lock
			result2 bool
			result3 error
		})
	}
	fake.acquireSchedulingLockReturnsOnCall[i] = struct {
		result1 lock.Lock
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) Builds(arg1 db.Page) ([]db.Build, db.Pagination, error) {
	fake.buildsMutex.Lock()
	ret, specificReturn := fake.buildsReturnsOnCall[len(fake.buildsArgsForCall)]
	fake.buildsArgsForCall = append(fake.buildsArgsForCall, struct {
		arg1 db.Page
	}{arg1})
	fake.recordInvocation("Builds", []interface{}{arg1})
	fake.buildsMutex.Unlock()
	if fake.BuildsStub != nil {
		return fake.BuildsStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.buildsReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePipeline) BuildsCallCount() int {
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	return len(fake.buildsArgsForCall)
}

func (fake *FakePipeline) BuildsCalls(stub func(db.Page) ([]db.Build, db.Pagination, error)) {
	fake.buildsMutex.Lock()
	defer fake.buildsMutex.Unlock()
	fake.BuildsStub = stub
}

func (fake *FakePipeline) BuildsArgsForCall(i int) db.Page {
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	argsForCall := fake.buildsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) BuildsReturns(result1 []db.Build, result2 db.Pagination, result3 error) {
	fake.buildsMutex.Lock()
	defer fake.buildsMutex.Unlock()
	fake.BuildsStub = nil
	fake.buildsReturns = struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) BuildsReturnsOnCall(i int, result1 []db.Build, result2 db.Pagination, result3 error) {
	fake.buildsMutex.Lock()
	defer fake.buildsMutex.Unlock()
	fake.BuildsStub = nil
	if fake.buildsReturnsOnCall == nil {
		fake.buildsReturnsOnCall = make(map[int]struct {
			result1 []db.Build
			result2 db.Pagination
			result3 error
		})
	}
	fake.buildsReturnsOnCall[i] = struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) BuildsWithTime(arg1 db.Page) ([]db.Build, db.Pagination, error) {
	fake.buildsWithTimeMutex.Lock()
	ret, specificReturn := fake.buildsWithTimeReturnsOnCall[len(fake.buildsWithTimeArgsForCall)]
	fake.buildsWithTimeArgsForCall = append(fake.buildsWithTimeArgsForCall, struct {
		arg1 db.Page
	}{arg1})
	fake.recordInvocation("BuildsWithTime", []interface{}{arg1})
	fake.buildsWithTimeMutex.Unlock()
	if fake.BuildsWithTimeStub != nil {
		return fake.BuildsWithTimeStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.buildsWithTimeReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePipeline) BuildsWithTimeCallCount() int {
	fake.buildsWithTimeMutex.RLock()
	defer fake.buildsWithTimeMutex.RUnlock()
	return len(fake.buildsWithTimeArgsForCall)
}

func (fake *FakePipeline) BuildsWithTimeCalls(stub func(db.Page) ([]db.Build, db.Pagination, error)) {
	fake.buildsWithTimeMutex.Lock()
	defer fake.buildsWithTimeMutex.Unlock()
	fake.BuildsWithTimeStub = stub
}

func (fake *FakePipeline) BuildsWithTimeArgsForCall(i int) db.Page {
	fake.buildsWithTimeMutex.RLock()
	defer fake.buildsWithTimeMutex.RUnlock()
	argsForCall := fake.buildsWithTimeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) BuildsWithTimeReturns(result1 []db.Build, result2 db.Pagination, result3 error) {
	fake.buildsWithTimeMutex.Lock()
	defer fake.buildsWithTimeMutex.Unlock()
	fake.BuildsWithTimeStub = nil
	fake.buildsWithTimeReturns = struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) BuildsWithTimeReturnsOnCall(i int, result1 []db.Build, result2 db.Pagination, result3 error) {
	fake.buildsWithTimeMutex.Lock()
	defer fake.buildsWithTimeMutex.Unlock()
	fake.BuildsWithTimeStub = nil
	if fake.buildsWithTimeReturnsOnCall == nil {
		fake.buildsWithTimeReturnsOnCall = make(map[int]struct {
			result1 []db.Build
			result2 db.Pagination
			result3 error
		})
	}
	fake.buildsWithTimeReturnsOnCall[i] = struct {
		result1 []db.Build
		result2 db.Pagination
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) Causality(arg1 int) ([]db.Cause, error) {
	fake.causalityMutex.Lock()
	ret, specificReturn := fake.causalityReturnsOnCall[len(fake.causalityArgsForCall)]
	fake.causalityArgsForCall = append(fake.causalityArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("Causality", []interface{}{arg1})
	fake.causalityMutex.Unlock()
	if fake.CausalityStub != nil {
		return fake.CausalityStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.causalityReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) CausalityCallCount() int {
	fake.causalityMutex.RLock()
	defer fake.causalityMutex.RUnlock()
	return len(fake.causalityArgsForCall)
}

func (fake *FakePipeline) CausalityCalls(stub func(int) ([]db.Cause, error)) {
	fake.causalityMutex.Lock()
	defer fake.causalityMutex.Unlock()
	fake.CausalityStub = stub
}

func (fake *FakePipeline) CausalityArgsForCall(i int) int {
	fake.causalityMutex.RLock()
	defer fake.causalityMutex.RUnlock()
	argsForCall := fake.causalityArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) CausalityReturns(result1 []db.Cause, result2 error) {
	fake.causalityMutex.Lock()
	defer fake.causalityMutex.Unlock()
	fake.CausalityStub = nil
	fake.causalityReturns = struct {
		result1 []db.Cause
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) CausalityReturnsOnCall(i int, result1 []db.Cause, result2 error) {
	fake.causalityMutex.Lock()
	defer fake.causalityMutex.Unlock()
	fake.CausalityStub = nil
	if fake.causalityReturnsOnCall == nil {
		fake.causalityReturnsOnCall = make(map[int]struct {
			result1 []db.Cause
			result2 error
		})
	}
	fake.causalityReturnsOnCall[i] = struct {
		result1 []db.Cause
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) CheckPaused() (bool, error) {
	fake.checkPausedMutex.Lock()
	ret, specificReturn := fake.checkPausedReturnsOnCall[len(fake.checkPausedArgsForCall)]
	fake.checkPausedArgsForCall = append(fake.checkPausedArgsForCall, struct {
	}{})
	fake.recordInvocation("CheckPaused", []interface{}{})
	fake.checkPausedMutex.Unlock()
	if fake.CheckPausedStub != nil {
		return fake.CheckPausedStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.checkPausedReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) CheckPausedCallCount() int {
	fake.checkPausedMutex.RLock()
	defer fake.checkPausedMutex.RUnlock()
	return len(fake.checkPausedArgsForCall)
}

func (fake *FakePipeline) CheckPausedCalls(stub func() (bool, error)) {
	fake.checkPausedMutex.Lock()
	defer fake.checkPausedMutex.Unlock()
	fake.CheckPausedStub = stub
}

func (fake *FakePipeline) CheckPausedReturns(result1 bool, result2 error) {
	fake.checkPausedMutex.Lock()
	defer fake.checkPausedMutex.Unlock()
	fake.CheckPausedStub = nil
	fake.checkPausedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) CheckPausedReturnsOnCall(i int, result1 bool, result2 error) {
	fake.checkPausedMutex.Lock()
	defer fake.checkPausedMutex.Unlock()
	fake.CheckPausedStub = nil
	if fake.checkPausedReturnsOnCall == nil {
		fake.checkPausedReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.checkPausedReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) ConfigVersion() db.ConfigVersion {
	fake.configVersionMutex.Lock()
	ret, specificReturn := fake.configVersionReturnsOnCall[len(fake.configVersionArgsForCall)]
	fake.configVersionArgsForCall = append(fake.configVersionArgsForCall, struct {
	}{})
	fake.recordInvocation("ConfigVersion", []interface{}{})
	fake.configVersionMutex.Unlock()
	if fake.ConfigVersionStub != nil {
		return fake.ConfigVersionStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.configVersionReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) ConfigVersionCallCount() int {
	fake.configVersionMutex.RLock()
	defer fake.configVersionMutex.RUnlock()
	return len(fake.configVersionArgsForCall)
}

func (fake *FakePipeline) ConfigVersionCalls(stub func() db.ConfigVersion) {
	fake.configVersionMutex.Lock()
	defer fake.configVersionMutex.Unlock()
	fake.ConfigVersionStub = stub
}

func (fake *FakePipeline) ConfigVersionReturns(result1 db.ConfigVersion) {
	fake.configVersionMutex.Lock()
	defer fake.configVersionMutex.Unlock()
	fake.ConfigVersionStub = nil
	fake.configVersionReturns = struct {
		result1 db.ConfigVersion
	}{result1}
}

func (fake *FakePipeline) ConfigVersionReturnsOnCall(i int, result1 db.ConfigVersion) {
	fake.configVersionMutex.Lock()
	defer fake.configVersionMutex.Unlock()
	fake.ConfigVersionStub = nil
	if fake.configVersionReturnsOnCall == nil {
		fake.configVersionReturnsOnCall = make(map[int]struct {
			result1 db.ConfigVersion
		})
	}
	fake.configVersionReturnsOnCall[i] = struct {
		result1 db.ConfigVersion
	}{result1}
}

func (fake *FakePipeline) CreateOneOffBuild() (db.Build, error) {
	fake.createOneOffBuildMutex.Lock()
	ret, specificReturn := fake.createOneOffBuildReturnsOnCall[len(fake.createOneOffBuildArgsForCall)]
	fake.createOneOffBuildArgsForCall = append(fake.createOneOffBuildArgsForCall, struct {
	}{})
	fake.recordInvocation("CreateOneOffBuild", []interface{}{})
	fake.createOneOffBuildMutex.Unlock()
	if fake.CreateOneOffBuildStub != nil {
		return fake.CreateOneOffBuildStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createOneOffBuildReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) CreateOneOffBuildCallCount() int {
	fake.createOneOffBuildMutex.RLock()
	defer fake.createOneOffBuildMutex.RUnlock()
	return len(fake.createOneOffBuildArgsForCall)
}

func (fake *FakePipeline) CreateOneOffBuildCalls(stub func() (db.Build, error)) {
	fake.createOneOffBuildMutex.Lock()
	defer fake.createOneOffBuildMutex.Unlock()
	fake.CreateOneOffBuildStub = stub
}

func (fake *FakePipeline) CreateOneOffBuildReturns(result1 db.Build, result2 error) {
	fake.createOneOffBuildMutex.Lock()
	defer fake.createOneOffBuildMutex.Unlock()
	fake.CreateOneOffBuildStub = nil
	fake.createOneOffBuildReturns = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) CreateOneOffBuildReturnsOnCall(i int, result1 db.Build, result2 error) {
	fake.createOneOffBuildMutex.Lock()
	defer fake.createOneOffBuildMutex.Unlock()
	fake.CreateOneOffBuildStub = nil
	if fake.createOneOffBuildReturnsOnCall == nil {
		fake.createOneOffBuildReturnsOnCall = make(map[int]struct {
			result1 db.Build
			result2 error
		})
	}
	fake.createOneOffBuildReturnsOnCall[i] = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) CreateStartedBuild(arg1 atc.Plan) (db.Build, error) {
	fake.createStartedBuildMutex.Lock()
	ret, specificReturn := fake.createStartedBuildReturnsOnCall[len(fake.createStartedBuildArgsForCall)]
	fake.createStartedBuildArgsForCall = append(fake.createStartedBuildArgsForCall, struct {
		arg1 atc.Plan
	}{arg1})
	fake.recordInvocation("CreateStartedBuild", []interface{}{arg1})
	fake.createStartedBuildMutex.Unlock()
	if fake.CreateStartedBuildStub != nil {
		return fake.CreateStartedBuildStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createStartedBuildReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) CreateStartedBuildCallCount() int {
	fake.createStartedBuildMutex.RLock()
	defer fake.createStartedBuildMutex.RUnlock()
	return len(fake.createStartedBuildArgsForCall)
}

func (fake *FakePipeline) CreateStartedBuildCalls(stub func(atc.Plan) (db.Build, error)) {
	fake.createStartedBuildMutex.Lock()
	defer fake.createStartedBuildMutex.Unlock()
	fake.CreateStartedBuildStub = stub
}

func (fake *FakePipeline) CreateStartedBuildArgsForCall(i int) atc.Plan {
	fake.createStartedBuildMutex.RLock()
	defer fake.createStartedBuildMutex.RUnlock()
	argsForCall := fake.createStartedBuildArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) CreateStartedBuildReturns(result1 db.Build, result2 error) {
	fake.createStartedBuildMutex.Lock()
	defer fake.createStartedBuildMutex.Unlock()
	fake.CreateStartedBuildStub = nil
	fake.createStartedBuildReturns = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) CreateStartedBuildReturnsOnCall(i int, result1 db.Build, result2 error) {
	fake.createStartedBuildMutex.Lock()
	defer fake.createStartedBuildMutex.Unlock()
	fake.CreateStartedBuildStub = nil
	if fake.createStartedBuildReturnsOnCall == nil {
		fake.createStartedBuildReturnsOnCall = make(map[int]struct {
			result1 db.Build
			result2 error
		})
	}
	fake.createStartedBuildReturnsOnCall[i] = struct {
		result1 db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) Dashboard() (db.Dashboard, error) {
	fake.dashboardMutex.Lock()
	ret, specificReturn := fake.dashboardReturnsOnCall[len(fake.dashboardArgsForCall)]
	fake.dashboardArgsForCall = append(fake.dashboardArgsForCall, struct {
	}{})
	fake.recordInvocation("Dashboard", []interface{}{})
	fake.dashboardMutex.Unlock()
	if fake.DashboardStub != nil {
		return fake.DashboardStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.dashboardReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) DashboardCallCount() int {
	fake.dashboardMutex.RLock()
	defer fake.dashboardMutex.RUnlock()
	return len(fake.dashboardArgsForCall)
}

func (fake *FakePipeline) DashboardCalls(stub func() (db.Dashboard, error)) {
	fake.dashboardMutex.Lock()
	defer fake.dashboardMutex.Unlock()
	fake.DashboardStub = stub
}

func (fake *FakePipeline) DashboardReturns(result1 db.Dashboard, result2 error) {
	fake.dashboardMutex.Lock()
	defer fake.dashboardMutex.Unlock()
	fake.DashboardStub = nil
	fake.dashboardReturns = struct {
		result1 db.Dashboard
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) DashboardReturnsOnCall(i int, result1 db.Dashboard, result2 error) {
	fake.dashboardMutex.Lock()
	defer fake.dashboardMutex.Unlock()
	fake.DashboardStub = nil
	if fake.dashboardReturnsOnCall == nil {
		fake.dashboardReturnsOnCall = make(map[int]struct {
			result1 db.Dashboard
			result2 error
		})
	}
	fake.dashboardReturnsOnCall[i] = struct {
		result1 db.Dashboard
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) DeleteBuildEventsByBuildIDs(arg1 []int) error {
	var arg1Copy []int
	if arg1 != nil {
		arg1Copy = make([]int, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.deleteBuildEventsByBuildIDsMutex.Lock()
	ret, specificReturn := fake.deleteBuildEventsByBuildIDsReturnsOnCall[len(fake.deleteBuildEventsByBuildIDsArgsForCall)]
	fake.deleteBuildEventsByBuildIDsArgsForCall = append(fake.deleteBuildEventsByBuildIDsArgsForCall, struct {
		arg1 []int
	}{arg1Copy})
	fake.recordInvocation("DeleteBuildEventsByBuildIDs", []interface{}{arg1Copy})
	fake.deleteBuildEventsByBuildIDsMutex.Unlock()
	if fake.DeleteBuildEventsByBuildIDsStub != nil {
		return fake.DeleteBuildEventsByBuildIDsStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.deleteBuildEventsByBuildIDsReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) DeleteBuildEventsByBuildIDsCallCount() int {
	fake.deleteBuildEventsByBuildIDsMutex.RLock()
	defer fake.deleteBuildEventsByBuildIDsMutex.RUnlock()
	return len(fake.deleteBuildEventsByBuildIDsArgsForCall)
}

func (fake *FakePipeline) DeleteBuildEventsByBuildIDsCalls(stub func([]int) error) {
	fake.deleteBuildEventsByBuildIDsMutex.Lock()
	defer fake.deleteBuildEventsByBuildIDsMutex.Unlock()
	fake.DeleteBuildEventsByBuildIDsStub = stub
}

func (fake *FakePipeline) DeleteBuildEventsByBuildIDsArgsForCall(i int) []int {
	fake.deleteBuildEventsByBuildIDsMutex.RLock()
	defer fake.deleteBuildEventsByBuildIDsMutex.RUnlock()
	argsForCall := fake.deleteBuildEventsByBuildIDsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) DeleteBuildEventsByBuildIDsReturns(result1 error) {
	fake.deleteBuildEventsByBuildIDsMutex.Lock()
	defer fake.deleteBuildEventsByBuildIDsMutex.Unlock()
	fake.DeleteBuildEventsByBuildIDsStub = nil
	fake.deleteBuildEventsByBuildIDsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) DeleteBuildEventsByBuildIDsReturnsOnCall(i int, result1 error) {
	fake.deleteBuildEventsByBuildIDsMutex.Lock()
	defer fake.deleteBuildEventsByBuildIDsMutex.Unlock()
	fake.DeleteBuildEventsByBuildIDsStub = nil
	if fake.deleteBuildEventsByBuildIDsReturnsOnCall == nil {
		fake.deleteBuildEventsByBuildIDsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteBuildEventsByBuildIDsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) Destroy() error {
	fake.destroyMutex.Lock()
	ret, specificReturn := fake.destroyReturnsOnCall[len(fake.destroyArgsForCall)]
	fake.destroyArgsForCall = append(fake.destroyArgsForCall, struct {
	}{})
	fake.recordInvocation("Destroy", []interface{}{})
	fake.destroyMutex.Unlock()
	if fake.DestroyStub != nil {
		return fake.DestroyStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.destroyReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) DestroyCallCount() int {
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	return len(fake.destroyArgsForCall)
}

func (fake *FakePipeline) DestroyCalls(stub func() error) {
	fake.destroyMutex.Lock()
	defer fake.destroyMutex.Unlock()
	fake.DestroyStub = stub
}

func (fake *FakePipeline) DestroyReturns(result1 error) {
	fake.destroyMutex.Lock()
	defer fake.destroyMutex.Unlock()
	fake.DestroyStub = nil
	fake.destroyReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) DestroyReturnsOnCall(i int, result1 error) {
	fake.destroyMutex.Lock()
	defer fake.destroyMutex.Unlock()
	fake.DestroyStub = nil
	if fake.destroyReturnsOnCall == nil {
		fake.destroyReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.destroyReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) Expose() error {
	fake.exposeMutex.Lock()
	ret, specificReturn := fake.exposeReturnsOnCall[len(fake.exposeArgsForCall)]
	fake.exposeArgsForCall = append(fake.exposeArgsForCall, struct {
	}{})
	fake.recordInvocation("Expose", []interface{}{})
	fake.exposeMutex.Unlock()
	if fake.ExposeStub != nil {
		return fake.ExposeStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.exposeReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) ExposeCallCount() int {
	fake.exposeMutex.RLock()
	defer fake.exposeMutex.RUnlock()
	return len(fake.exposeArgsForCall)
}

func (fake *FakePipeline) ExposeCalls(stub func() error) {
	fake.exposeMutex.Lock()
	defer fake.exposeMutex.Unlock()
	fake.ExposeStub = stub
}

func (fake *FakePipeline) ExposeReturns(result1 error) {
	fake.exposeMutex.Lock()
	defer fake.exposeMutex.Unlock()
	fake.ExposeStub = nil
	fake.exposeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) ExposeReturnsOnCall(i int, result1 error) {
	fake.exposeMutex.Lock()
	defer fake.exposeMutex.Unlock()
	fake.ExposeStub = nil
	if fake.exposeReturnsOnCall == nil {
		fake.exposeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.exposeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) GetAllPendingBuilds() (map[string][]db.Build, error) {
	fake.getAllPendingBuildsMutex.Lock()
	ret, specificReturn := fake.getAllPendingBuildsReturnsOnCall[len(fake.getAllPendingBuildsArgsForCall)]
	fake.getAllPendingBuildsArgsForCall = append(fake.getAllPendingBuildsArgsForCall, struct {
	}{})
	fake.recordInvocation("GetAllPendingBuilds", []interface{}{})
	fake.getAllPendingBuildsMutex.Unlock()
	if fake.GetAllPendingBuildsStub != nil {
		return fake.GetAllPendingBuildsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getAllPendingBuildsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) GetAllPendingBuildsCallCount() int {
	fake.getAllPendingBuildsMutex.RLock()
	defer fake.getAllPendingBuildsMutex.RUnlock()
	return len(fake.getAllPendingBuildsArgsForCall)
}

func (fake *FakePipeline) GetAllPendingBuildsCalls(stub func() (map[string][]db.Build, error)) {
	fake.getAllPendingBuildsMutex.Lock()
	defer fake.getAllPendingBuildsMutex.Unlock()
	fake.GetAllPendingBuildsStub = stub
}

func (fake *FakePipeline) GetAllPendingBuildsReturns(result1 map[string][]db.Build, result2 error) {
	fake.getAllPendingBuildsMutex.Lock()
	defer fake.getAllPendingBuildsMutex.Unlock()
	fake.GetAllPendingBuildsStub = nil
	fake.getAllPendingBuildsReturns = struct {
		result1 map[string][]db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) GetAllPendingBuildsReturnsOnCall(i int, result1 map[string][]db.Build, result2 error) {
	fake.getAllPendingBuildsMutex.Lock()
	defer fake.getAllPendingBuildsMutex.Unlock()
	fake.GetAllPendingBuildsStub = nil
	if fake.getAllPendingBuildsReturnsOnCall == nil {
		fake.getAllPendingBuildsReturnsOnCall = make(map[int]struct {
			result1 map[string][]db.Build
			result2 error
		})
	}
	fake.getAllPendingBuildsReturnsOnCall[i] = struct {
		result1 map[string][]db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) GetBuildsWithVersionAsInput(arg1 int, arg2 int) ([]db.Build, error) {
	fake.getBuildsWithVersionAsInputMutex.Lock()
	ret, specificReturn := fake.getBuildsWithVersionAsInputReturnsOnCall[len(fake.getBuildsWithVersionAsInputArgsForCall)]
	fake.getBuildsWithVersionAsInputArgsForCall = append(fake.getBuildsWithVersionAsInputArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("GetBuildsWithVersionAsInput", []interface{}{arg1, arg2})
	fake.getBuildsWithVersionAsInputMutex.Unlock()
	if fake.GetBuildsWithVersionAsInputStub != nil {
		return fake.GetBuildsWithVersionAsInputStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getBuildsWithVersionAsInputReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) GetBuildsWithVersionAsInputCallCount() int {
	fake.getBuildsWithVersionAsInputMutex.RLock()
	defer fake.getBuildsWithVersionAsInputMutex.RUnlock()
	return len(fake.getBuildsWithVersionAsInputArgsForCall)
}

func (fake *FakePipeline) GetBuildsWithVersionAsInputCalls(stub func(int, int) ([]db.Build, error)) {
	fake.getBuildsWithVersionAsInputMutex.Lock()
	defer fake.getBuildsWithVersionAsInputMutex.Unlock()
	fake.GetBuildsWithVersionAsInputStub = stub
}

func (fake *FakePipeline) GetBuildsWithVersionAsInputArgsForCall(i int) (int, int) {
	fake.getBuildsWithVersionAsInputMutex.RLock()
	defer fake.getBuildsWithVersionAsInputMutex.RUnlock()
	argsForCall := fake.getBuildsWithVersionAsInputArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePipeline) GetBuildsWithVersionAsInputReturns(result1 []db.Build, result2 error) {
	fake.getBuildsWithVersionAsInputMutex.Lock()
	defer fake.getBuildsWithVersionAsInputMutex.Unlock()
	fake.GetBuildsWithVersionAsInputStub = nil
	fake.getBuildsWithVersionAsInputReturns = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) GetBuildsWithVersionAsInputReturnsOnCall(i int, result1 []db.Build, result2 error) {
	fake.getBuildsWithVersionAsInputMutex.Lock()
	defer fake.getBuildsWithVersionAsInputMutex.Unlock()
	fake.GetBuildsWithVersionAsInputStub = nil
	if fake.getBuildsWithVersionAsInputReturnsOnCall == nil {
		fake.getBuildsWithVersionAsInputReturnsOnCall = make(map[int]struct {
			result1 []db.Build
			result2 error
		})
	}
	fake.getBuildsWithVersionAsInputReturnsOnCall[i] = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) GetBuildsWithVersionAsOutput(arg1 int, arg2 int) ([]db.Build, error) {
	fake.getBuildsWithVersionAsOutputMutex.Lock()
	ret, specificReturn := fake.getBuildsWithVersionAsOutputReturnsOnCall[len(fake.getBuildsWithVersionAsOutputArgsForCall)]
	fake.getBuildsWithVersionAsOutputArgsForCall = append(fake.getBuildsWithVersionAsOutputArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("GetBuildsWithVersionAsOutput", []interface{}{arg1, arg2})
	fake.getBuildsWithVersionAsOutputMutex.Unlock()
	if fake.GetBuildsWithVersionAsOutputStub != nil {
		return fake.GetBuildsWithVersionAsOutputStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getBuildsWithVersionAsOutputReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) GetBuildsWithVersionAsOutputCallCount() int {
	fake.getBuildsWithVersionAsOutputMutex.RLock()
	defer fake.getBuildsWithVersionAsOutputMutex.RUnlock()
	return len(fake.getBuildsWithVersionAsOutputArgsForCall)
}

func (fake *FakePipeline) GetBuildsWithVersionAsOutputCalls(stub func(int, int) ([]db.Build, error)) {
	fake.getBuildsWithVersionAsOutputMutex.Lock()
	defer fake.getBuildsWithVersionAsOutputMutex.Unlock()
	fake.GetBuildsWithVersionAsOutputStub = stub
}

func (fake *FakePipeline) GetBuildsWithVersionAsOutputArgsForCall(i int) (int, int) {
	fake.getBuildsWithVersionAsOutputMutex.RLock()
	defer fake.getBuildsWithVersionAsOutputMutex.RUnlock()
	argsForCall := fake.getBuildsWithVersionAsOutputArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePipeline) GetBuildsWithVersionAsOutputReturns(result1 []db.Build, result2 error) {
	fake.getBuildsWithVersionAsOutputMutex.Lock()
	defer fake.getBuildsWithVersionAsOutputMutex.Unlock()
	fake.GetBuildsWithVersionAsOutputStub = nil
	fake.getBuildsWithVersionAsOutputReturns = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) GetBuildsWithVersionAsOutputReturnsOnCall(i int, result1 []db.Build, result2 error) {
	fake.getBuildsWithVersionAsOutputMutex.Lock()
	defer fake.getBuildsWithVersionAsOutputMutex.Unlock()
	fake.GetBuildsWithVersionAsOutputStub = nil
	if fake.getBuildsWithVersionAsOutputReturnsOnCall == nil {
		fake.getBuildsWithVersionAsOutputReturnsOnCall = make(map[int]struct {
			result1 []db.Build
			result2 error
		})
	}
	fake.getBuildsWithVersionAsOutputReturnsOnCall[i] = struct {
		result1 []db.Build
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) Groups() atc.GroupConfigs {
	fake.groupsMutex.Lock()
	ret, specificReturn := fake.groupsReturnsOnCall[len(fake.groupsArgsForCall)]
	fake.groupsArgsForCall = append(fake.groupsArgsForCall, struct {
	}{})
	fake.recordInvocation("Groups", []interface{}{})
	fake.groupsMutex.Unlock()
	if fake.GroupsStub != nil {
		return fake.GroupsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.groupsReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) GroupsCallCount() int {
	fake.groupsMutex.RLock()
	defer fake.groupsMutex.RUnlock()
	return len(fake.groupsArgsForCall)
}

func (fake *FakePipeline) GroupsCalls(stub func() atc.GroupConfigs) {
	fake.groupsMutex.Lock()
	defer fake.groupsMutex.Unlock()
	fake.GroupsStub = stub
}

func (fake *FakePipeline) GroupsReturns(result1 atc.GroupConfigs) {
	fake.groupsMutex.Lock()
	defer fake.groupsMutex.Unlock()
	fake.GroupsStub = nil
	fake.groupsReturns = struct {
		result1 atc.GroupConfigs
	}{result1}
}

func (fake *FakePipeline) GroupsReturnsOnCall(i int, result1 atc.GroupConfigs) {
	fake.groupsMutex.Lock()
	defer fake.groupsMutex.Unlock()
	fake.GroupsStub = nil
	if fake.groupsReturnsOnCall == nil {
		fake.groupsReturnsOnCall = make(map[int]struct {
			result1 atc.GroupConfigs
		})
	}
	fake.groupsReturnsOnCall[i] = struct {
		result1 atc.GroupConfigs
	}{result1}
}

func (fake *FakePipeline) Hide() error {
	fake.hideMutex.Lock()
	ret, specificReturn := fake.hideReturnsOnCall[len(fake.hideArgsForCall)]
	fake.hideArgsForCall = append(fake.hideArgsForCall, struct {
	}{})
	fake.recordInvocation("Hide", []interface{}{})
	fake.hideMutex.Unlock()
	if fake.HideStub != nil {
		return fake.HideStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.hideReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) HideCallCount() int {
	fake.hideMutex.RLock()
	defer fake.hideMutex.RUnlock()
	return len(fake.hideArgsForCall)
}

func (fake *FakePipeline) HideCalls(stub func() error) {
	fake.hideMutex.Lock()
	defer fake.hideMutex.Unlock()
	fake.HideStub = stub
}

func (fake *FakePipeline) HideReturns(result1 error) {
	fake.hideMutex.Lock()
	defer fake.hideMutex.Unlock()
	fake.HideStub = nil
	fake.hideReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) HideReturnsOnCall(i int, result1 error) {
	fake.hideMutex.Lock()
	defer fake.hideMutex.Unlock()
	fake.HideStub = nil
	if fake.hideReturnsOnCall == nil {
		fake.hideReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.hideReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) ID() int {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct {
	}{})
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if fake.IDStub != nil {
		return fake.IDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.iDReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakePipeline) IDCalls(stub func() int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = stub
}

func (fake *FakePipeline) IDReturns(result1 int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) IDReturnsOnCall(i int, result1 int) {
	fake.iDMutex.Lock()
	defer fake.iDMutex.Unlock()
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) Job(arg1 string) (db.Job, bool, error) {
	fake.jobMutex.Lock()
	ret, specificReturn := fake.jobReturnsOnCall[len(fake.jobArgsForCall)]
	fake.jobArgsForCall = append(fake.jobArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Job", []interface{}{arg1})
	fake.jobMutex.Unlock()
	if fake.JobStub != nil {
		return fake.JobStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.jobReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePipeline) JobCallCount() int {
	fake.jobMutex.RLock()
	defer fake.jobMutex.RUnlock()
	return len(fake.jobArgsForCall)
}

func (fake *FakePipeline) JobCalls(stub func(string) (db.Job, bool, error)) {
	fake.jobMutex.Lock()
	defer fake.jobMutex.Unlock()
	fake.JobStub = stub
}

func (fake *FakePipeline) JobArgsForCall(i int) string {
	fake.jobMutex.RLock()
	defer fake.jobMutex.RUnlock()
	argsForCall := fake.jobArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) JobReturns(result1 db.Job, result2 bool, result3 error) {
	fake.jobMutex.Lock()
	defer fake.jobMutex.Unlock()
	fake.JobStub = nil
	fake.jobReturns = struct {
		result1 db.Job
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) JobReturnsOnCall(i int, result1 db.Job, result2 bool, result3 error) {
	fake.jobMutex.Lock()
	defer fake.jobMutex.Unlock()
	fake.JobStub = nil
	if fake.jobReturnsOnCall == nil {
		fake.jobReturnsOnCall = make(map[int]struct {
			result1 db.Job
			result2 bool
			result3 error
		})
	}
	fake.jobReturnsOnCall[i] = struct {
		result1 db.Job
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) Jobs() (db.Jobs, error) {
	fake.jobsMutex.Lock()
	ret, specificReturn := fake.jobsReturnsOnCall[len(fake.jobsArgsForCall)]
	fake.jobsArgsForCall = append(fake.jobsArgsForCall, struct {
	}{})
	fake.recordInvocation("Jobs", []interface{}{})
	fake.jobsMutex.Unlock()
	if fake.JobsStub != nil {
		return fake.JobsStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.jobsReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) JobsCallCount() int {
	fake.jobsMutex.RLock()
	defer fake.jobsMutex.RUnlock()
	return len(fake.jobsArgsForCall)
}

func (fake *FakePipeline) JobsCalls(stub func() (db.Jobs, error)) {
	fake.jobsMutex.Lock()
	defer fake.jobsMutex.Unlock()
	fake.JobsStub = stub
}

func (fake *FakePipeline) JobsReturns(result1 db.Jobs, result2 error) {
	fake.jobsMutex.Lock()
	defer fake.jobsMutex.Unlock()
	fake.JobsStub = nil
	fake.jobsReturns = struct {
		result1 db.Jobs
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) JobsReturnsOnCall(i int, result1 db.Jobs, result2 error) {
	fake.jobsMutex.Lock()
	defer fake.jobsMutex.Unlock()
	fake.JobsStub = nil
	if fake.jobsReturnsOnCall == nil {
		fake.jobsReturnsOnCall = make(map[int]struct {
			result1 db.Jobs
			result2 error
		})
	}
	fake.jobsReturnsOnCall[i] = struct {
		result1 db.Jobs
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) LoadVersionsDB() (*algorithm.VersionsDB, error) {
	fake.loadVersionsDBMutex.Lock()
	ret, specificReturn := fake.loadVersionsDBReturnsOnCall[len(fake.loadVersionsDBArgsForCall)]
	fake.loadVersionsDBArgsForCall = append(fake.loadVersionsDBArgsForCall, struct {
	}{})
	fake.recordInvocation("LoadVersionsDB", []interface{}{})
	fake.loadVersionsDBMutex.Unlock()
	if fake.LoadVersionsDBStub != nil {
		return fake.LoadVersionsDBStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.loadVersionsDBReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) LoadVersionsDBCallCount() int {
	fake.loadVersionsDBMutex.RLock()
	defer fake.loadVersionsDBMutex.RUnlock()
	return len(fake.loadVersionsDBArgsForCall)
}

func (fake *FakePipeline) LoadVersionsDBCalls(stub func() (*algorithm.VersionsDB, error)) {
	fake.loadVersionsDBMutex.Lock()
	defer fake.loadVersionsDBMutex.Unlock()
	fake.LoadVersionsDBStub = stub
}

func (fake *FakePipeline) LoadVersionsDBReturns(result1 *algorithm.VersionsDB, result2 error) {
	fake.loadVersionsDBMutex.Lock()
	defer fake.loadVersionsDBMutex.Unlock()
	fake.LoadVersionsDBStub = nil
	fake.loadVersionsDBReturns = struct {
		result1 *algorithm.VersionsDB
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) LoadVersionsDBReturnsOnCall(i int, result1 *algorithm.VersionsDB, result2 error) {
	fake.loadVersionsDBMutex.Lock()
	defer fake.loadVersionsDBMutex.Unlock()
	fake.LoadVersionsDBStub = nil
	if fake.loadVersionsDBReturnsOnCall == nil {
		fake.loadVersionsDBReturnsOnCall = make(map[int]struct {
			result1 *algorithm.VersionsDB
			result2 error
		})
	}
	fake.loadVersionsDBReturnsOnCall[i] = struct {
		result1 *algorithm.VersionsDB
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct {
	}{})
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if fake.NameStub != nil {
		return fake.NameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.nameReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakePipeline) NameCalls(stub func() string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = stub
}

func (fake *FakePipeline) NameReturns(result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) NameReturnsOnCall(i int, result1 string) {
	fake.nameMutex.Lock()
	defer fake.nameMutex.Unlock()
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) Pause() error {
	fake.pauseMutex.Lock()
	ret, specificReturn := fake.pauseReturnsOnCall[len(fake.pauseArgsForCall)]
	fake.pauseArgsForCall = append(fake.pauseArgsForCall, struct {
	}{})
	fake.recordInvocation("Pause", []interface{}{})
	fake.pauseMutex.Unlock()
	if fake.PauseStub != nil {
		return fake.PauseStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pauseReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) PauseCallCount() int {
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	return len(fake.pauseArgsForCall)
}

func (fake *FakePipeline) PauseCalls(stub func() error) {
	fake.pauseMutex.Lock()
	defer fake.pauseMutex.Unlock()
	fake.PauseStub = stub
}

func (fake *FakePipeline) PauseReturns(result1 error) {
	fake.pauseMutex.Lock()
	defer fake.pauseMutex.Unlock()
	fake.PauseStub = nil
	fake.pauseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) PauseReturnsOnCall(i int, result1 error) {
	fake.pauseMutex.Lock()
	defer fake.pauseMutex.Unlock()
	fake.PauseStub = nil
	if fake.pauseReturnsOnCall == nil {
		fake.pauseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.pauseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) Paused() bool {
	fake.pausedMutex.Lock()
	ret, specificReturn := fake.pausedReturnsOnCall[len(fake.pausedArgsForCall)]
	fake.pausedArgsForCall = append(fake.pausedArgsForCall, struct {
	}{})
	fake.recordInvocation("Paused", []interface{}{})
	fake.pausedMutex.Unlock()
	if fake.PausedStub != nil {
		return fake.PausedStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.pausedReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) PausedCallCount() int {
	fake.pausedMutex.RLock()
	defer fake.pausedMutex.RUnlock()
	return len(fake.pausedArgsForCall)
}

func (fake *FakePipeline) PausedCalls(stub func() bool) {
	fake.pausedMutex.Lock()
	defer fake.pausedMutex.Unlock()
	fake.PausedStub = stub
}

func (fake *FakePipeline) PausedReturns(result1 bool) {
	fake.pausedMutex.Lock()
	defer fake.pausedMutex.Unlock()
	fake.PausedStub = nil
	fake.pausedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePipeline) PausedReturnsOnCall(i int, result1 bool) {
	fake.pausedMutex.Lock()
	defer fake.pausedMutex.Unlock()
	fake.PausedStub = nil
	if fake.pausedReturnsOnCall == nil {
		fake.pausedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.pausedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePipeline) Public() bool {
	fake.publicMutex.Lock()
	ret, specificReturn := fake.publicReturnsOnCall[len(fake.publicArgsForCall)]
	fake.publicArgsForCall = append(fake.publicArgsForCall, struct {
	}{})
	fake.recordInvocation("Public", []interface{}{})
	fake.publicMutex.Unlock()
	if fake.PublicStub != nil {
		return fake.PublicStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.publicReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) PublicCallCount() int {
	fake.publicMutex.RLock()
	defer fake.publicMutex.RUnlock()
	return len(fake.publicArgsForCall)
}

func (fake *FakePipeline) PublicCalls(stub func() bool) {
	fake.publicMutex.Lock()
	defer fake.publicMutex.Unlock()
	fake.PublicStub = stub
}

func (fake *FakePipeline) PublicReturns(result1 bool) {
	fake.publicMutex.Lock()
	defer fake.publicMutex.Unlock()
	fake.PublicStub = nil
	fake.publicReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakePipeline) PublicReturnsOnCall(i int, result1 bool) {
	fake.publicMutex.Lock()
	defer fake.publicMutex.Unlock()
	fake.PublicStub = nil
	if fake.publicReturnsOnCall == nil {
		fake.publicReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.publicReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakePipeline) Reload() (bool, error) {
	fake.reloadMutex.Lock()
	ret, specificReturn := fake.reloadReturnsOnCall[len(fake.reloadArgsForCall)]
	fake.reloadArgsForCall = append(fake.reloadArgsForCall, struct {
	}{})
	fake.recordInvocation("Reload", []interface{}{})
	fake.reloadMutex.Unlock()
	if fake.ReloadStub != nil {
		return fake.ReloadStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.reloadReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) ReloadCallCount() int {
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	return len(fake.reloadArgsForCall)
}

func (fake *FakePipeline) ReloadCalls(stub func() (bool, error)) {
	fake.reloadMutex.Lock()
	defer fake.reloadMutex.Unlock()
	fake.ReloadStub = stub
}

func (fake *FakePipeline) ReloadReturns(result1 bool, result2 error) {
	fake.reloadMutex.Lock()
	defer fake.reloadMutex.Unlock()
	fake.ReloadStub = nil
	fake.reloadReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) ReloadReturnsOnCall(i int, result1 bool, result2 error) {
	fake.reloadMutex.Lock()
	defer fake.reloadMutex.Unlock()
	fake.ReloadStub = nil
	if fake.reloadReturnsOnCall == nil {
		fake.reloadReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.reloadReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) Rename(arg1 string) error {
	fake.renameMutex.Lock()
	ret, specificReturn := fake.renameReturnsOnCall[len(fake.renameArgsForCall)]
	fake.renameArgsForCall = append(fake.renameArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Rename", []interface{}{arg1})
	fake.renameMutex.Unlock()
	if fake.RenameStub != nil {
		return fake.RenameStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.renameReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) RenameCallCount() int {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	return len(fake.renameArgsForCall)
}

func (fake *FakePipeline) RenameCalls(stub func(string) error) {
	fake.renameMutex.Lock()
	defer fake.renameMutex.Unlock()
	fake.RenameStub = stub
}

func (fake *FakePipeline) RenameArgsForCall(i int) string {
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	argsForCall := fake.renameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) RenameReturns(result1 error) {
	fake.renameMutex.Lock()
	defer fake.renameMutex.Unlock()
	fake.RenameStub = nil
	fake.renameReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) RenameReturnsOnCall(i int, result1 error) {
	fake.renameMutex.Lock()
	defer fake.renameMutex.Unlock()
	fake.RenameStub = nil
	if fake.renameReturnsOnCall == nil {
		fake.renameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.renameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) Resource(arg1 string) (db.Resource, bool, error) {
	fake.resourceMutex.Lock()
	ret, specificReturn := fake.resourceReturnsOnCall[len(fake.resourceArgsForCall)]
	fake.resourceArgsForCall = append(fake.resourceArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("Resource", []interface{}{arg1})
	fake.resourceMutex.Unlock()
	if fake.ResourceStub != nil {
		return fake.ResourceStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.resourceReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePipeline) ResourceCallCount() int {
	fake.resourceMutex.RLock()
	defer fake.resourceMutex.RUnlock()
	return len(fake.resourceArgsForCall)
}

func (fake *FakePipeline) ResourceCalls(stub func(string) (db.Resource, bool, error)) {
	fake.resourceMutex.Lock()
	defer fake.resourceMutex.Unlock()
	fake.ResourceStub = stub
}

func (fake *FakePipeline) ResourceArgsForCall(i int) string {
	fake.resourceMutex.RLock()
	defer fake.resourceMutex.RUnlock()
	argsForCall := fake.resourceArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) ResourceReturns(result1 db.Resource, result2 bool, result3 error) {
	fake.resourceMutex.Lock()
	defer fake.resourceMutex.Unlock()
	fake.ResourceStub = nil
	fake.resourceReturns = struct {
		result1 db.Resource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) ResourceReturnsOnCall(i int, result1 db.Resource, result2 bool, result3 error) {
	fake.resourceMutex.Lock()
	defer fake.resourceMutex.Unlock()
	fake.ResourceStub = nil
	if fake.resourceReturnsOnCall == nil {
		fake.resourceReturnsOnCall = make(map[int]struct {
			result1 db.Resource
			result2 bool
			result3 error
		})
	}
	fake.resourceReturnsOnCall[i] = struct {
		result1 db.Resource
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) ResourceType(arg1 string) (db.ResourceType, bool, error) {
	fake.resourceTypeMutex.Lock()
	ret, specificReturn := fake.resourceTypeReturnsOnCall[len(fake.resourceTypeArgsForCall)]
	fake.resourceTypeArgsForCall = append(fake.resourceTypeArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("ResourceType", []interface{}{arg1})
	fake.resourceTypeMutex.Unlock()
	if fake.ResourceTypeStub != nil {
		return fake.ResourceTypeStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.resourceTypeReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePipeline) ResourceTypeCallCount() int {
	fake.resourceTypeMutex.RLock()
	defer fake.resourceTypeMutex.RUnlock()
	return len(fake.resourceTypeArgsForCall)
}

func (fake *FakePipeline) ResourceTypeCalls(stub func(string) (db.ResourceType, bool, error)) {
	fake.resourceTypeMutex.Lock()
	defer fake.resourceTypeMutex.Unlock()
	fake.ResourceTypeStub = stub
}

func (fake *FakePipeline) ResourceTypeArgsForCall(i int) string {
	fake.resourceTypeMutex.RLock()
	defer fake.resourceTypeMutex.RUnlock()
	argsForCall := fake.resourceTypeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) ResourceTypeReturns(result1 db.ResourceType, result2 bool, result3 error) {
	fake.resourceTypeMutex.Lock()
	defer fake.resourceTypeMutex.Unlock()
	fake.ResourceTypeStub = nil
	fake.resourceTypeReturns = struct {
		result1 db.ResourceType
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) ResourceTypeReturnsOnCall(i int, result1 db.ResourceType, result2 bool, result3 error) {
	fake.resourceTypeMutex.Lock()
	defer fake.resourceTypeMutex.Unlock()
	fake.ResourceTypeStub = nil
	if fake.resourceTypeReturnsOnCall == nil {
		fake.resourceTypeReturnsOnCall = make(map[int]struct {
			result1 db.ResourceType
			result2 bool
			result3 error
		})
	}
	fake.resourceTypeReturnsOnCall[i] = struct {
		result1 db.ResourceType
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) ResourceTypes() (db.ResourceTypes, error) {
	fake.resourceTypesMutex.Lock()
	ret, specificReturn := fake.resourceTypesReturnsOnCall[len(fake.resourceTypesArgsForCall)]
	fake.resourceTypesArgsForCall = append(fake.resourceTypesArgsForCall, struct {
	}{})
	fake.recordInvocation("ResourceTypes", []interface{}{})
	fake.resourceTypesMutex.Unlock()
	if fake.ResourceTypesStub != nil {
		return fake.ResourceTypesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.resourceTypesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) ResourceTypesCallCount() int {
	fake.resourceTypesMutex.RLock()
	defer fake.resourceTypesMutex.RUnlock()
	return len(fake.resourceTypesArgsForCall)
}

func (fake *FakePipeline) ResourceTypesCalls(stub func() (db.ResourceTypes, error)) {
	fake.resourceTypesMutex.Lock()
	defer fake.resourceTypesMutex.Unlock()
	fake.ResourceTypesStub = stub
}

func (fake *FakePipeline) ResourceTypesReturns(result1 db.ResourceTypes, result2 error) {
	fake.resourceTypesMutex.Lock()
	defer fake.resourceTypesMutex.Unlock()
	fake.ResourceTypesStub = nil
	fake.resourceTypesReturns = struct {
		result1 db.ResourceTypes
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) ResourceTypesReturnsOnCall(i int, result1 db.ResourceTypes, result2 error) {
	fake.resourceTypesMutex.Lock()
	defer fake.resourceTypesMutex.Unlock()
	fake.ResourceTypesStub = nil
	if fake.resourceTypesReturnsOnCall == nil {
		fake.resourceTypesReturnsOnCall = make(map[int]struct {
			result1 db.ResourceTypes
			result2 error
		})
	}
	fake.resourceTypesReturnsOnCall[i] = struct {
		result1 db.ResourceTypes
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) ResourceVersion(arg1 int) (atc.ResourceVersion, bool, error) {
	fake.resourceVersionMutex.Lock()
	ret, specificReturn := fake.resourceVersionReturnsOnCall[len(fake.resourceVersionArgsForCall)]
	fake.resourceVersionArgsForCall = append(fake.resourceVersionArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("ResourceVersion", []interface{}{arg1})
	fake.resourceVersionMutex.Unlock()
	if fake.ResourceVersionStub != nil {
		return fake.ResourceVersionStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	fakeReturns := fake.resourceVersionReturns
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePipeline) ResourceVersionCallCount() int {
	fake.resourceVersionMutex.RLock()
	defer fake.resourceVersionMutex.RUnlock()
	return len(fake.resourceVersionArgsForCall)
}

func (fake *FakePipeline) ResourceVersionCalls(stub func(int) (atc.ResourceVersion, bool, error)) {
	fake.resourceVersionMutex.Lock()
	defer fake.resourceVersionMutex.Unlock()
	fake.ResourceVersionStub = stub
}

func (fake *FakePipeline) ResourceVersionArgsForCall(i int) int {
	fake.resourceVersionMutex.RLock()
	defer fake.resourceVersionMutex.RUnlock()
	argsForCall := fake.resourceVersionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePipeline) ResourceVersionReturns(result1 atc.ResourceVersion, result2 bool, result3 error) {
	fake.resourceVersionMutex.Lock()
	defer fake.resourceVersionMutex.Unlock()
	fake.ResourceVersionStub = nil
	fake.resourceVersionReturns = struct {
		result1 atc.ResourceVersion
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) ResourceVersionReturnsOnCall(i int, result1 atc.ResourceVersion, result2 bool, result3 error) {
	fake.resourceVersionMutex.Lock()
	defer fake.resourceVersionMutex.Unlock()
	fake.ResourceVersionStub = nil
	if fake.resourceVersionReturnsOnCall == nil {
		fake.resourceVersionReturnsOnCall = make(map[int]struct {
			result1 atc.ResourceVersion
			result2 bool
			result3 error
		})
	}
	fake.resourceVersionReturnsOnCall[i] = struct {
		result1 atc.ResourceVersion
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePipeline) Resources() (db.Resources, error) {
	fake.resourcesMutex.Lock()
	ret, specificReturn := fake.resourcesReturnsOnCall[len(fake.resourcesArgsForCall)]
	fake.resourcesArgsForCall = append(fake.resourcesArgsForCall, struct {
	}{})
	fake.recordInvocation("Resources", []interface{}{})
	fake.resourcesMutex.Unlock()
	if fake.ResourcesStub != nil {
		return fake.ResourcesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.resourcesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePipeline) ResourcesCallCount() int {
	fake.resourcesMutex.RLock()
	defer fake.resourcesMutex.RUnlock()
	return len(fake.resourcesArgsForCall)
}

func (fake *FakePipeline) ResourcesCalls(stub func() (db.Resources, error)) {
	fake.resourcesMutex.Lock()
	defer fake.resourcesMutex.Unlock()
	fake.ResourcesStub = stub
}

func (fake *FakePipeline) ResourcesReturns(result1 db.Resources, result2 error) {
	fake.resourcesMutex.Lock()
	defer fake.resourcesMutex.Unlock()
	fake.ResourcesStub = nil
	fake.resourcesReturns = struct {
		result1 db.Resources
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) ResourcesReturnsOnCall(i int, result1 db.Resources, result2 error) {
	fake.resourcesMutex.Lock()
	defer fake.resourcesMutex.Unlock()
	fake.ResourcesStub = nil
	if fake.resourcesReturnsOnCall == nil {
		fake.resourcesReturnsOnCall = make(map[int]struct {
			result1 db.Resources
			result2 error
		})
	}
	fake.resourcesReturnsOnCall[i] = struct {
		result1 db.Resources
		result2 error
	}{result1, result2}
}

func (fake *FakePipeline) TeamID() int {
	fake.teamIDMutex.Lock()
	ret, specificReturn := fake.teamIDReturnsOnCall[len(fake.teamIDArgsForCall)]
	fake.teamIDArgsForCall = append(fake.teamIDArgsForCall, struct {
	}{})
	fake.recordInvocation("TeamID", []interface{}{})
	fake.teamIDMutex.Unlock()
	if fake.TeamIDStub != nil {
		return fake.TeamIDStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.teamIDReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) TeamIDCallCount() int {
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	return len(fake.teamIDArgsForCall)
}

func (fake *FakePipeline) TeamIDCalls(stub func() int) {
	fake.teamIDMutex.Lock()
	defer fake.teamIDMutex.Unlock()
	fake.TeamIDStub = stub
}

func (fake *FakePipeline) TeamIDReturns(result1 int) {
	fake.teamIDMutex.Lock()
	defer fake.teamIDMutex.Unlock()
	fake.TeamIDStub = nil
	fake.teamIDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) TeamIDReturnsOnCall(i int, result1 int) {
	fake.teamIDMutex.Lock()
	defer fake.teamIDMutex.Unlock()
	fake.TeamIDStub = nil
	if fake.teamIDReturnsOnCall == nil {
		fake.teamIDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.teamIDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakePipeline) TeamName() string {
	fake.teamNameMutex.Lock()
	ret, specificReturn := fake.teamNameReturnsOnCall[len(fake.teamNameArgsForCall)]
	fake.teamNameArgsForCall = append(fake.teamNameArgsForCall, struct {
	}{})
	fake.recordInvocation("TeamName", []interface{}{})
	fake.teamNameMutex.Unlock()
	if fake.TeamNameStub != nil {
		return fake.TeamNameStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.teamNameReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) TeamNameCallCount() int {
	fake.teamNameMutex.RLock()
	defer fake.teamNameMutex.RUnlock()
	return len(fake.teamNameArgsForCall)
}

func (fake *FakePipeline) TeamNameCalls(stub func() string) {
	fake.teamNameMutex.Lock()
	defer fake.teamNameMutex.Unlock()
	fake.TeamNameStub = stub
}

func (fake *FakePipeline) TeamNameReturns(result1 string) {
	fake.teamNameMutex.Lock()
	defer fake.teamNameMutex.Unlock()
	fake.TeamNameStub = nil
	fake.teamNameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) TeamNameReturnsOnCall(i int, result1 string) {
	fake.teamNameMutex.Lock()
	defer fake.teamNameMutex.Unlock()
	fake.TeamNameStub = nil
	if fake.teamNameReturnsOnCall == nil {
		fake.teamNameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.teamNameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePipeline) Unpause() error {
	fake.unpauseMutex.Lock()
	ret, specificReturn := fake.unpauseReturnsOnCall[len(fake.unpauseArgsForCall)]
	fake.unpauseArgsForCall = append(fake.unpauseArgsForCall, struct {
	}{})
	fake.recordInvocation("Unpause", []interface{}{})
	fake.unpauseMutex.Unlock()
	if fake.UnpauseStub != nil {
		return fake.UnpauseStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.unpauseReturns
	return fakeReturns.result1
}

func (fake *FakePipeline) UnpauseCallCount() int {
	fake.unpauseMutex.RLock()
	defer fake.unpauseMutex.RUnlock()
	return len(fake.unpauseArgsForCall)
}

func (fake *FakePipeline) UnpauseCalls(stub func() error) {
	fake.unpauseMutex.Lock()
	defer fake.unpauseMutex.Unlock()
	fake.UnpauseStub = stub
}

func (fake *FakePipeline) UnpauseReturns(result1 error) {
	fake.unpauseMutex.Lock()
	defer fake.unpauseMutex.Unlock()
	fake.UnpauseStub = nil
	fake.unpauseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) UnpauseReturnsOnCall(i int, result1 error) {
	fake.unpauseMutex.Lock()
	defer fake.unpauseMutex.Unlock()
	fake.UnpauseStub = nil
	if fake.unpauseReturnsOnCall == nil {
		fake.unpauseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.unpauseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePipeline) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.acquireSchedulingLockMutex.RLock()
	defer fake.acquireSchedulingLockMutex.RUnlock()
	fake.buildsMutex.RLock()
	defer fake.buildsMutex.RUnlock()
	fake.buildsWithTimeMutex.RLock()
	defer fake.buildsWithTimeMutex.RUnlock()
	fake.causalityMutex.RLock()
	defer fake.causalityMutex.RUnlock()
	fake.checkPausedMutex.RLock()
	defer fake.checkPausedMutex.RUnlock()
	fake.configVersionMutex.RLock()
	defer fake.configVersionMutex.RUnlock()
	fake.createOneOffBuildMutex.RLock()
	defer fake.createOneOffBuildMutex.RUnlock()
	fake.createStartedBuildMutex.RLock()
	defer fake.createStartedBuildMutex.RUnlock()
	fake.dashboardMutex.RLock()
	defer fake.dashboardMutex.RUnlock()
	fake.deleteBuildEventsByBuildIDsMutex.RLock()
	defer fake.deleteBuildEventsByBuildIDsMutex.RUnlock()
	fake.destroyMutex.RLock()
	defer fake.destroyMutex.RUnlock()
	fake.exposeMutex.RLock()
	defer fake.exposeMutex.RUnlock()
	fake.getAllPendingBuildsMutex.RLock()
	defer fake.getAllPendingBuildsMutex.RUnlock()
	fake.getBuildsWithVersionAsInputMutex.RLock()
	defer fake.getBuildsWithVersionAsInputMutex.RUnlock()
	fake.getBuildsWithVersionAsOutputMutex.RLock()
	defer fake.getBuildsWithVersionAsOutputMutex.RUnlock()
	fake.groupsMutex.RLock()
	defer fake.groupsMutex.RUnlock()
	fake.hideMutex.RLock()
	defer fake.hideMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.jobMutex.RLock()
	defer fake.jobMutex.RUnlock()
	fake.jobsMutex.RLock()
	defer fake.jobsMutex.RUnlock()
	fake.loadVersionsDBMutex.RLock()
	defer fake.loadVersionsDBMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.pauseMutex.RLock()
	defer fake.pauseMutex.RUnlock()
	fake.pausedMutex.RLock()
	defer fake.pausedMutex.RUnlock()
	fake.publicMutex.RLock()
	defer fake.publicMutex.RUnlock()
	fake.reloadMutex.RLock()
	defer fake.reloadMutex.RUnlock()
	fake.renameMutex.RLock()
	defer fake.renameMutex.RUnlock()
	fake.resourceMutex.RLock()
	defer fake.resourceMutex.RUnlock()
	fake.resourceTypeMutex.RLock()
	defer fake.resourceTypeMutex.RUnlock()
	fake.resourceTypesMutex.RLock()
	defer fake.resourceTypesMutex.RUnlock()
	fake.resourceVersionMutex.RLock()
	defer fake.resourceVersionMutex.RUnlock()
	fake.resourcesMutex.RLock()
	defer fake.resourcesMutex.RUnlock()
	fake.teamIDMutex.RLock()
	defer fake.teamIDMutex.RUnlock()
	fake.teamNameMutex.RLock()
	defer fake.teamNameMutex.RUnlock()
	fake.unpauseMutex.RLock()
	defer fake.unpauseMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePipeline) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ db.Pipeline = new(FakePipeline)
